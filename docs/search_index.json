[
["index.html", "Курс статистики для биохимиков Глава 1 Что я хочу видеть в данной книге?", " Курс статистики для биохимиков АЕП 2019-12-04 Глава 1 Что я хочу видеть в данной книге? Структура книги установка R: R/RStudio/Rtools/пакеты преимущества R базовый синтаксис главы статистики с кодом для расчетов/примеров типы данных (непрерывные, дискретные) и соответствующие типы в R импорт данных, фильтрация, манипуляции постановка эксперимента (рандомизация и дизайн в R) summary, гистограммы, scatterplots, boxplots, pairs сравнение групп анализ распределения, типы предпосылок доверительный интервал: нормальный, t и bootstrap; концепция интервала связь доверительного интервала и p-value, уровень значимости и типы ошибок, вероятность найти эффект и не найти, мощность тест перестановок нулевая гипотеза эмпирический p-value справочник по основным операциям в R переменные типы данных и где что лучше использовать импорт данных, ошибки, пропуски операции пайплайны симуляции чистые данные и манипуляции с ними типы графиков: R-base, ggplot+cowplot/plotly, ggpubr "],
["сравнение-двух-групп-непрерывные-переменные.html", "Глава 2 Сравнение двух групп (непрерывные переменные) 2.1 Нулевая гипотеза", " Глава 2 Сравнение двух групп (непрерывные переменные) 2.1 Нулевая гипотеза "],
["справочник-по-манипуляциями-с-данными.html", "Глава 3 Справочник по манипуляциями с данными 3.1 План 3.2 Папки и проекты 3.3 Импорт", " Глава 3 Справочник по манипуляциями с данными 3.1 План проекты импорт - комманды rio::import read.table, read_xslx, read_csv … манипуляции с данными (все с реальными примерами!) проверка типов данных десятичные разделители ошибки, строковые преобразования выбросы - ошибки непрерывных переменных =&gt; график и исправить категориальные переменные - уникальные значения и опечатки, регистры пропущенные данные преобразования данных и пайплайны типы пайплайнов 100 %&gt;% sqrt() %&gt;% log() x = 100 %&gt;% sqrt() %&gt;% log() x &lt;- 100 %&gt;% sqrt() %&gt;% log() 100 %&gt;% sqrt() %&gt;% log() -&gt; x =/&lt;-/-&gt;/%&gt;%/%&lt;&gt;%/%$%, select, rename, mutate, filter, group_by, summarise, pull/pluck, stack, rerun, extrac_grid, *join, str*, regex, rstatix, naniar, tidy(…), augment, {.} pivot* nest/unnest/map*/.x ggplot 3.2 Папки и проекты Для удобства работы над каким-то проектом (например, обучение работы в R на наших занятиях) удобно завести под это специальную папку и держать в ней все файлы. 3.2.1 Работа с папками Чтобы R знал, в какой папке искать файлы, можно один раз задать базовую папку командой setwd(&quot;C:/Path/to/my folder&quot;), либо при каждом обращении к файлу указывать полный путь к файлу, например import(&quot;C:/Path/to/my folder/my file.xlsx&quot;) (внимание, даже в Windows используем прямой слэш - “/”!). Однако это не очень удобно, изменение имени папки черевато ошибками. Поэтому у счастливых пользователей RStudio есть возможность облегчить себе жизнь путем использованием проектов. 3.2.2 Работа с проектами Для создания нового проекта нужно в меню открыть File &gt; New Project &gt; New Directory &gt; New Project, после чего нужно будет задать имя корневой папки для проектов (например, C:/Users/ThatsMe/R/) и имя папки для текущего проекта (например, BiochemStatsCourse), после чего нажать Create Project. После этого данная папка будет считаться базовой и можно будет дальнейшие файлы создавать в ней самой или ее подпапках. Если вы кинули файл my file.xls в подпапку data, то его можно будет прочитать командой import(&quot;data/my file.xlsx&quot;) (уже не нужно указывать полный путь к папке, который будет C:/Users/ThatsMe/R/BiochemStatsCourse/data/my file.xlsx). Более подробно об этом можно почитать здесь, здесь или здесь. 3.3 Импорт Данные, которые мы можем анализировать могут быть созданы в какой угодно программе (Excel, другие статистические программы, софт различных приборов и т.д.). Мы даже можем анализировать данные Web-страниц. Самый частый в моей практике случай - использование файлов, созданных в Excel или экспортированных в этот формат. Наилучшим образом подходят для импорта в R форматы CSV и XSLX, однако можно научить R читать практически любой формат (кроме зашифрованных производителем). Для примера скачаем тестовый файл по ссылке и сохраним его вручную в нужную папку. Однако это можно сделать и с помощью R. Для этого сначала сгенерируем имя временного файла и сохраним его в переменную tmp (или же вы можете прописать путь к папке и имя файла, если далее хотите с ним иметь дело), затем сохраним в него скачанный файл. После завершения работы скрипта временный файл будет удален, а если Вы сами указали путь и имя файла, тогда он останется. # запишем в переменную имя файла filename = &quot;data/iris.xlsx&quot; # скачиваем файл по ссылке download.file(&quot;https://github.com/lapotok/biochemstat_book/blob/master/data/iris.xlsx?raw=true&quot;, filename) Теперь этот файл можем открыть. Форматов бывает много, однако одна из наиболее продвинутых библиотек rio позволяет открывать практически любые распространенные форматы. library(rio) suppressPackageStartupMessages(library(tidyverse)) suppressPackageStartupMessages(library(magrittr)) my_iris = import(&quot;data/iris.xlsx&quot;) my_iris %&gt;% str() ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : chr &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; ... my_iris$Species %&gt;% unique() ## [1] &quot;setosa&quot; &quot;versicolor&quot; &quot;virginica&quot; Видим, что файл открылся правильно, т.к. правильное число строк и столбцов числовые переменные действительно имеют тип num (а не текстовый тип chr и не фактор factor) в списке видов нет ничего лишнего, никаких ошибочно написанных Теперь для разнообразия откроем файл с ошибками. #download.file(&quot;https://github.com/lapotok/biochemstat_book/blob/master/data/bad_data_example.xlsx?raw=true&quot;, &quot;data/bad_data_example.xlsx&quot;) bad = import(&quot;data/bad_data_example.xlsx&quot;) bad %&gt;% str() # смотрим на типы данных разных переменных ## &#39;data.frame&#39;: 38 obs. of 5 variables: ## $ ID : chr &quot;PL01.It1&quot; &quot;PL01.It2&quot; &quot;PL01.It3&quot; &quot;PL01.It4&quot; ... ## $ Weight : chr &quot;44&quot; &quot;99.2&quot; &quot;22&quot; &quot;67&quot; ... ## $ Species : chr &quot;Genus1 species1&quot; &quot;Genus1 species1&quot; &quot;Genus1 species1&quot; &quot;Genus1 species2&quot; ... ## $ Num ticks: num 203 0 70 0 197 0 125 229 138 218 ... ## $ Пол : chr &quot;F&quot; &quot;M&quot; &quot;f&quot; &quot;m&quot; ... bad$Species %&gt;% unique() # все ли названия правильные? нет ничего лишнего? ## [1] &quot;Genus1 species1&quot; &quot;Genus1 species2&quot; &quot;Genus1 sp&quot; ## [4] &quot;Genus1 sp.&quot; &quot;Genus1 spp.&quot; &quot;NA&quot; ## [7] NA &quot;Genus2 hz&quot; &quot;?&quot; ## [10] &quot;Genus2 ?&quot; &quot;Na&quot; &quot;hz&quot; ## [13] &quot;Genus2 species1 ?&quot; &quot;na&quot; &quot;Genus2 species1&quot; bad$&quot;Пол&quot; %&gt;% unique() # должно быть 2 пола или пропуск в данных, так ли это? ## [1] &quot;F&quot; &quot;M&quot; &quot;f&quot; &quot;m&quot; NA Какие могут быть ошибки в данных? В файле, который мы рассматриваем в качестве антипримера есть следующие ошибки неправильный десятичный разделитель в Weight и как следствие вся переменная определяется как строковая, а не численная пропущенные данные, абы как названные (надо составить указания для R в формате регулярных выражений, что заменять на NA без кавычек - специальное обозначение для пропущенных данных) русскоязычные названия переменных и названия с пробелами, что может вызывать неудобство в работе, например необходимость их закавычивать при обращении к ним (bad$`Num ticks`) в колонке “Пол” буквы разного регистра обозначают одно и то же Какие-то из ошибок можно исправить уже на этапе подготовки данных (см. рекомендации). Идеальная форма представления данных воплощается в концепте “tidy data”. Учимся исправлять ошибки, которые мы уже научились находить. library(naniar) good = bad %&gt;% mutate(Weight = str_replace(Weight, &quot;,&quot;, &quot;.&quot;)) %&gt;% # исправляем ошибку: заменяем , на . mutate(Weight = as.numeric(Weight)) %&gt;% # теперь изменяем тип переменной на числовой rename(Gender=`Пол`, Num_ticks=`Num ticks`) %&gt;% # переименовываем переменные, чтобы дальше было удобнее replace_with_na_all(~ str_detect(.x, regex(&quot;(^na$)|(.*hz.*)|(.*\\\\?.*)&quot;, ignore_case = T))) %&gt;% # заменяем на NA (см. дальше) mutate(Gender = toupper(Gender)) # для унификации заменяем все буквы на большие # а теперь как? good %&gt;% str() ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 38 obs. of 5 variables: ## $ ID : chr &quot;PL01.It1&quot; &quot;PL01.It2&quot; &quot;PL01.It3&quot; &quot;PL01.It4&quot; ... ## $ Weight : num 44 99.2 22 67 91.8 95 13 51.1 57 97 ... ## $ Species : chr &quot;Genus1 species1&quot; &quot;Genus1 species1&quot; &quot;Genus1 species1&quot; &quot;Genus1 species2&quot; ... ## $ Num_ticks: num 203 0 70 0 197 0 125 229 138 218 ... ## $ Gender : chr &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; ... good$Species %&gt;% unique() ## [1] &quot;Genus1 species1&quot; &quot;Genus1 species2&quot; &quot;Genus1 sp&quot; &quot;Genus1 sp.&quot; ## [5] &quot;Genus1 spp.&quot; NA &quot;Genus2 species1&quot; good$Gender %&gt;% unique() ## [1] &quot;F&quot; &quot;M&quot; NA Здесь стоит отдельно остановиться на выражении regex(&quot;(^na$)|(.*hz.*)|(.*\\\\?.*)&quot;, ignore_case = T). Речь идет об использовании регулярных выражений. Это способ указывать критерий для поиска или замен в строках. Простейший житейский пример регулярного выражения (правда, синтаксис там не очень правильный, зато понятный) - это когда мы выбираем файлы Excel выражением *.xls(x). Здесь я приведу один пример работы с ними: проверяем адреса электронной почты на правильность (это простенький пример, не претендующий на абсолютную правильность). # поиск по паттерну mails = c(&quot;good@mail1.ru&quot;, &quot;good@mail2.ru&quot;, &quot;bad@mail@ru&quot;, &quot;another*bad@mail.ru&quot;) # список адресов mail_regex = &quot;^[A-Za-z0-9.+_-]+@[A-Za-z0-9.+_-]+\\\\.[A-Za-z0-9.+_-]{2,}$&quot; # регулярное выражение str_detect(mails, mail_regex) # проверяем адреса на соответствие выражению ## [1] TRUE TRUE FALSE FALSE Разберем по частям ^ в начале обозначает, что мы ищем с начала строки включительно, а $ - что искомый элемент заканчивается концом строки; т.е. в итоге мы хотим чтобы строка полностью соответствовала шаблону, а не ее какая-то часть; [A-Za-z0-9.+_-] - это любой из символов в скобках, причем все большие буквы задаются диапазоном A-Z; аналогично задаются все маленькие и все цифры; [A-Za-z0-9.+_-]+ - это вышеупомянутые символы, которые повторяются 1 и более раз (это указывается символом +; если может быть 0 и более раз, то используем символ *; чтобы в явном виде указать диапазон используем синтаксис {min,max}); . вне скобок обозначает любой символ, поэтому для обозначения точки нужно использовать сочетание \\\\.. Здесь я не буду подробнее останавливаться на регулярных выражениях, Вы можете подробнее прочитать про это по ссылкам далее [1, 2, 3]. "]
]
